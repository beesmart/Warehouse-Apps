<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Carton & Pallet Planner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Tailwind via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body class="bg-gray-100">

<div id="root"></div>

<!-- React + ReactDOM from CDN -->
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

<!-- Babel for JSX -->
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<script type="text/babel">
const { useState, useMemo, useRef, useEffect } = React;

// =====================================================
// CONSTANTS & CONFIGURATION
// =====================================================
const DIMENSION_COLORS = {
  L: "#ef4444", // red
  W: "#3b82f6", // blue
  H: "#10b981", // green
};

const ORIENTATION_LABELS = {
  upright: { primary: "L", secondary: "W" },
  "upright-rotated": { primary: "W", secondary: "L" },
  "laid-side-l": { primary: "W", secondary: "H" },
  "laid-side-w": { primary: "L", secondary: "H" },
  "laid-h-l": { primary: "L", secondary: "H" },
  "laid-h-w": { primary: "H", secondary: "W" },
  mixed: { primary: "L", secondary: "W" },
};

const PALLET_SIZES = [
  { label: "UK Standard (1200 × 1000 mm)", L: 1200, W: 1000 },
  { label: "Euro Pallet (1200 × 800 mm)", L: 1200, W: 800 },
  { label: "Half Pallet (800 × 600 mm)", L: 800, W: 600 },
  { label: "Custom size", L: null, W: null },
];

// =====================================================
// UTILITY FUNCTIONS
// =====================================================
const getVisibleLabels = (pattern = "") => {
  // Find the base pattern without the "mixed-" prefix
  const basePattern = pattern.replace("mixed-", "");
  
  // Return the labels for the pattern, or default to upright
  return ORIENTATION_LABELS[basePattern] || ORIENTATION_LABELS.upright;
};

const getRowLabels = (pattern, rotated) => {
  const labels = getVisibleLabels(pattern);
  
  // For mixed patterns, swap labels when row is rotated
  if (pattern.startsWith("mixed") && rotated) {
    return { primary: labels.secondary, secondary: labels.primary };
  }
  return labels;
};

const numberFmt = (n) => n.toLocaleString();

// =====================================================
// 3D SCENE UTILITIES
// =====================================================
const create3DScene = (mountRef, config) => {
  const { width, height, cameraDistance = 3000, cameraHeight = 2000 } = config;
  
  // Scene setup
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf5f5f5);
  
  // Camera
  const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);
  camera.position.set(cameraDistance, cameraHeight, cameraDistance);
  camera.lookAt(0, 0, 0);
  
  // Renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(width, height);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  mountRef.current.appendChild(renderer.domElement);
  
  // Lighting
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);
  
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
  directionalLight.position.set(1000, 2000, 1000);
  directionalLight.castShadow = true;
  directionalLight.shadow.camera.near = 0.1;
  directionalLight.shadow.camera.far = 5000;
  directionalLight.shadow.camera.left = -2000;
  directionalLight.shadow.camera.right = 2000;
  directionalLight.shadow.camera.top = 2000;
  directionalLight.shadow.camera.bottom = -2000;
  scene.add(directionalLight);
  
  // Ground plane
  const groundGeometry = new THREE.PlaneGeometry(5000, 5000);
  const groundMaterial = new THREE.MeshLambertMaterial({ color: 0xe0e0e0 });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -10;
  ground.receiveShadow = true;
  scene.add(ground);
  
  return { scene, camera, renderer };
};

const addPalletBase = (scene, palletL, palletW) => {
  const geometry = new THREE.BoxGeometry(palletL, 100, palletW);
  const material = new THREE.MeshLambertMaterial({ color: 0x8b7355 });
  const pallet = new THREE.Mesh(geometry, material);
  pallet.position.y = 50;
  pallet.castShadow = true;
  pallet.receiveShadow = true;
  scene.add(pallet);
  return pallet;
};

const addHeightGuide = (scene, palletL, palletW, palletH) => {
  // Transparent plane at max height
  const planeGeometry = new THREE.PlaneGeometry(palletL, palletW);
  const planeMaterial = new THREE.MeshBasicMaterial({
    color: 0x60a5fa,
    opacity: 0.15,
    transparent: true,
    side: THREE.DoubleSide,
  });
  const plane = new THREE.Mesh(planeGeometry, planeMaterial);
  plane.rotation.x = -Math.PI / 2;
  plane.position.y = palletH + 100; // 100 = pallet base height
  scene.add(plane);
  
  // Dashed outline
  const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(palletL, palletH, palletW));
  const material = new THREE.LineDashedMaterial({
    color: 0x3b82f6,
    dashSize: 50,
    gapSize: 30,
    opacity: 0.4,
    transparent: true,
  });
  const outline = new THREE.LineSegments(edges, material);
  outline.computeLineDistances();
  outline.position.y = palletH / 2 + 100;
  scene.add(outline);
};

// =====================================================
// 3D PALLET VIEW COMPONENT
// =====================================================
function PalletView3D({ 
  palletL, palletW, palletH, 
  cartonL, cartonW, cartonH, 
  pattern, perLayer, layers, 
  patternRows, palletTile, cartonWeight 
}) {
  const mountRef = useRef(null);
  const sceneRef = useRef(null);
  const rendererRef = useRef(null);
  const frameRef = useRef(null);
  const [viewMode, setViewMode] = useState('3D');
  
  // Calculate metrics
  const palletSurfaceArea = palletL * palletW;
  const palletVolume = palletL * palletW * palletH;
  const usedSurfaceArea = (palletTile.usedL || 0) * (palletTile.usedW || 0);
  const surfaceUsage = palletSurfaceArea > 0 ? (usedSurfaceArea / palletSurfaceArea) * 100 : 0;
  const cartonsVolume = perLayer * layers * cartonL * cartonW * cartonH;
  const volumeUsage = palletVolume > 0 ? (cartonsVolume / palletVolume) * 100 : 0;
  
  useEffect(() => {
    if (!mountRef.current || viewMode !== '3D') return;
    
    const width = mountRef.current.clientWidth;
    const height = 400;
    
    const { scene, camera, renderer } = create3DScene(mountRef, { 
      width, 
      height,
      cameraDistance: 2500,
      cameraHeight: 2000 
    });
    
    sceneRef.current = scene;
    rendererRef.current = renderer;
    
    // Add pallet and height guide
    addPalletBase(scene, palletL, palletW);
    addHeightGuide(scene, palletL, palletW, palletH);
    
    // Materials for cartons
    const standardMaterial = new THREE.MeshLambertMaterial({ color: 0x4a9eff });
    const rotatedMaterial = new THREE.MeshLambertMaterial({ color: 0x60a5fa });
    const cartonGeometry = new THREE.BoxGeometry(1, 1, 1);
    const cartonEdges = new THREE.EdgesGeometry(cartonGeometry);
    const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x1e40af, linewidth: 1 });
    
    // Add cartons
    for (let layer = 0; layer < layers; layer++) {
      const yOffset = 100 + layer * cartonH + cartonH / 2;
      
      if (patternRows) {
        // Mixed pattern
        let zStart = -palletW / 2;
        
        patternRows.forEach((row) => {
          const { rotated, countL, boxL: rowBoxL, boxW: rowBoxW } = row;
          const rowUsedL = countL * rowBoxL;
          const xStart = -rowUsedL / 2;
          
          for (let i = 0; i < countL; i++) {
            const carton = new THREE.Mesh(cartonGeometry, rotated ? rotatedMaterial : standardMaterial);
            const edges = new THREE.LineSegments(cartonEdges, edgeMaterial);
            
            const xPos = xStart + rowBoxL / 2 + i * rowBoxL;
            const zPos = zStart + rowBoxW / 2;
            
            carton.scale.set(rowBoxL, cartonH, rowBoxW);
            edges.scale.set(rowBoxL, cartonH, rowBoxW);
            carton.position.set(xPos, yOffset, zPos);
            edges.position.set(xPos, yOffset, zPos);
            
            carton.castShadow = true;
            carton.receiveShadow = true;
            
            scene.add(carton);
            scene.add(edges);
          }
          
          zStart += rowBoxW;
        });
      } else {
        // Uniform pattern
        const countL = Math.floor(palletL / cartonL);
        const countW = Math.floor(palletW / cartonW);
        const usedL = countL * cartonL;
        const usedW = countW * cartonW;
        const xStart = -usedL / 2;
        const zStart = -usedW / 2;
        
        for (let i = 0; i < countL; i++) {
          for (let j = 0; j < countW; j++) {
            const carton = new THREE.Mesh(cartonGeometry, standardMaterial);
            const edges = new THREE.LineSegments(cartonEdges, edgeMaterial);
            
            carton.scale.set(cartonL, cartonH, cartonW);
            edges.scale.set(cartonL, cartonH, cartonW);
            
            const xPos = xStart + cartonL / 2 + i * cartonL;
            const zPos = zStart + cartonW / 2 + j * cartonW;
            
            carton.position.set(xPos, yOffset, zPos);
            edges.position.set(xPos, yOffset, zPos);
            
            carton.castShadow = true;
            carton.receiveShadow = true;
            
            scene.add(carton);
            scene.add(edges);
          }
        }
      }
    }
    
    // Mouse controls
    let isDragging = false;
    let previousMouseX = 0;
    let previousMouseY = 0;
    let rotationX = Math.PI / 4;
    let rotationY = 0.3;
    
    const handleMouseDown = (e) => {
      isDragging = true;
      previousMouseX = e.clientX;
      previousMouseY = e.clientY;
      mountRef.current.style.cursor = 'grabbing';
    };
    
    const handleMouseMove = (e) => {
      if (!isDragging) return;
      
      const deltaX = e.clientX - previousMouseX;
      const deltaY = e.clientY - previousMouseY;
      
      rotationX += deltaX * 0.01;
      rotationY = Math.max(0.1, Math.min(1.2, rotationY - deltaY * 0.005));
      
      previousMouseX = e.clientX;
      previousMouseY = e.clientY;
    };
    
    const handleMouseUp = () => {
      isDragging = false;
      mountRef.current.style.cursor = 'grab';
    };
    
    // Add event listeners
    mountRef.current.addEventListener('mousedown', handleMouseDown);
    mountRef.current.addEventListener('mousemove', handleMouseMove);
    mountRef.current.addEventListener('mouseup', handleMouseUp);
    mountRef.current.addEventListener('mouseleave', handleMouseUp);
    window.addEventListener('mouseup', handleMouseUp);
    window.addEventListener('mousemove', handleMouseMove);
    mountRef.current.style.cursor = 'grab';
    
    // Animation loop
    const animate = () => {
      frameRef.current = requestAnimationFrame(animate);
      
      const radius = 3000;
      const height = 800 + rotationY * 1500;
      
      camera.position.x = Math.sin(rotationX) * radius;
      camera.position.y = height;
      camera.position.z = Math.cos(rotationX) * radius;
      camera.lookAt(0, palletH / 2, 0);
      
      renderer.render(scene, camera);
    };
    animate();
    
    // Cleanup
    return () => {
      if (frameRef.current) cancelAnimationFrame(frameRef.current);
      if (mountRef.current && rendererRef.current) {
        mountRef.current.removeChild(rendererRef.current.domElement);
      }
      if (rendererRef.current) rendererRef.current.dispose();
    };
  }, [palletL, palletW, palletH, cartonL, cartonW, cartonH, pattern, perLayer, layers, patternRows, viewMode]);
  
  return (
    <div className="p-4 border rounded-2xl shadow-sm bg-white">
      <div className="flex items-center justify-between mb-2">
        <h4 className="font-semibold">Pallet Visualization</h4>
        <div className="flex gap-1">
          <button
            onClick={() => setViewMode('2D')}
            className={`px-3 py-1 text-sm rounded-lg transition-colors ${
              viewMode === '2D' ? 'bg-blue-500 text-white' : 'bg-gray-100 hover:bg-gray-200'
            }`}
          >
            2D
          </button>
          <button
            onClick={() => setViewMode('3D')}
            className={`px-3 py-1 text-sm rounded-lg transition-colors ${
              viewMode === '3D' ? 'bg-blue-500 text-white' : 'bg-gray-100 hover:bg-gray-200'
            }`}
          >
            3D
          </button>
        </div>
      </div>
      
      {viewMode === '3D' ? (
        <>
          <div ref={mountRef} className="bg-gray-50 rounded-xl overflow-hidden" style={{ height: '400px' }} />
          <div className="text-xs text-gray-500 mt-2 text-center">Click and drag to rotate view</div>
        </>
      ) : (
        <LayerGrid2D
          spaceL={palletL}
          spaceW={palletW}
          boxL={cartonL}
          boxW={cartonW}
          boxH={cartonH}
          countL={Math.floor(palletL / cartonL)}
          countW={Math.floor(palletW / cartonW)}
          usedL={Math.floor(palletL / cartonL) * cartonL}
          usedW={Math.floor(palletW / cartonW) * cartonW}
          patternRows={patternRows}
          pattern={palletTile.pattern}
        />
      )}
      
      <div className="grid grid-cols-2 gap-2 text-sm mt-2">
        <div className="grid grid-cols-2 gap-2">
          <div><span className="text-gray-500">Layers:</span> {layers}</div>
          <div><span className="text-gray-500">Cartons/layer:</span> {perLayer}</div>
          <div><span className="text-gray-500">Total cartons:</span> {perLayer * layers}</div>
          <div><span className="text-gray-500">Total weight:</span> {(perLayer * layers * cartonWeight).toFixed(1)} kg</div>
        </div>
        <div className="grid grid-cols-2 gap-2">
          <div><span className="text-gray-500">Surface usage:</span> {surfaceUsage.toFixed(1)}%</div>
          <div><span className="text-gray-500">Volume usage:</span> {volumeUsage.toFixed(1)}%</div>
          <div><span className="text-gray-500">Stack height:</span> {layers * cartonH} mm</div>
          <div><span className="text-gray-500">Height unused:</span> {palletH - (layers * cartonH)} mm</div>
        </div>
      </div>
    </div>
  );
}

// =====================================================
// 2D LAYER GRID COMPONENT
// =====================================================
function LayerGrid2D({ 
  spaceL, spaceW, 
  boxL, boxW, boxH, 
  countL, countW, 
  usedL, usedW, 
  patternRows, pattern 
}) {
  const SVG_W = 520;
  const SVG_H = 320;
  const scale = Math.min(SVG_W / spaceL, SVG_H / spaceW);
  const pad = 6;
  const outerW = spaceL * scale;
  const outerH = spaceW * scale;
  
  const renderBox = (x, y, width, height, rotated, rowIndex, colIndex) => {
    const labels = rotated && pattern.startsWith("mixed") 
      ? getRowLabels(pattern, rotated)
      : getVisibleLabels(pattern);
    
    const key = `${rowIndex}-${colIndex}`;
    
    return (
      <g key={`carton-${key}`}>
        <rect
          x={x + 1}
          y={y + 1}
          width={width - 2}
          height={height - 2}
          fill={rotated ? "#fef3c7" : "#ffffff"}
          stroke="#111827"
          strokeWidth={0.8}
          rx={4}
        />
        {/* X-axis arrow and label */}
        <line
          x1={x + 5}
          y1={y + height / 2}
          x2={x + width - 5}
          y2={y + height / 2}
          stroke={DIMENSION_COLORS[labels.primary]}
          strokeWidth="1"
          markerEnd="url(#arrowhead)"
        />
        <text
          x={x + width / 2}
          y={y + height / 2 - 5}
          textAnchor="middle"
          fontSize="12"
          fill={DIMENSION_COLORS[labels.primary]}
        >
          {labels.primary}
        </text>
        {/* Y-axis arrow and label */}
        <line
          x1={x + width / 2}
          y1={y + 5}
          x2={x + width / 2}
          y2={y + height - 5}
          stroke={DIMENSION_COLORS[labels.secondary]}
          strokeWidth="1"
          markerEnd="url(#arrowhead)"
        />
        <text
          x={x + width / 2 + 8}
          y={y + height / 2}
          textAnchor="start"
          fontSize="12"
          fill={DIMENSION_COLORS[labels.secondary]}
        >
          {labels.secondary}
        </text>
      </g>
    );
  };
  
  let yOffset = 0;
  
  return (
    <div className="relative">
      <svg width={SVG_W + pad * 2} height={SVG_H + pad * 2} className="bg-gray-50 rounded-xl">
        <defs>
          <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#111827" />
          </marker>
        </defs>
        <g transform={`translate(${pad + (SVG_W - outerW) / 2}, ${pad + (SVG_H - outerH) / 2})`}>
          <rect x={0} y={0} width={outerW} height={outerH} fill="none" stroke="#9ca3af" strokeDasharray="6 6" />
          
          {patternRows
            ? patternRows.map((row, rowIndex) => {
                const { rotated, countL, boxL: rowBoxL, boxW: rowBoxW } = row;
                const y = yOffset * scale;
                yOffset += rowBoxW;
                
                return Array.from({ length: countL }).map((_, i) => {
                  const x = i * rowBoxL * scale;
                  return renderBox(x, y, rowBoxL * scale, rowBoxW * scale, rotated, rowIndex, i);
                });
              })
            : Array.from({ length: countL }).map((_, i) =>
                Array.from({ length: countW }).map((_, j) => {
                  const x = i * boxL * scale;
                  const y = j * boxW * scale;
                  return renderBox(x, y, boxL * scale, boxW * scale, false, i, j);
                })
              )}
        </g>
      </svg>
      
      {/* Legend */}
      <div className="flex justify-center gap-4 mt-2 text-xs text-gray-700">
        {Object.entries(DIMENSION_COLORS).map(([label, color]) => (
          <div key={label} className="flex items-center gap-1">
            <div
              style={{ backgroundColor: color }}
              className="w-3 h-3 rounded-sm"
            />
            <span>{label} dimension</span>
          </div>
        ))}
      </div>
    </div>
  );
}

// =====================================================
// BEST TILE CALCULATOR
// =====================================================
function bestTile(boxL, boxW, boxH, spaceL, spaceW, spaceH, allowVerticalFlip = true) {
  // Validate inputs
  if (boxL <= 0 || boxW <= 0 || boxH <= 0 || spaceL <= 0 || spaceW <= 0 || spaceH <= 0) {
    return {
      countL: 0,
      countW: 0,
      layers: 0,
      perLayer: 0,
      total: 0,
      boxL,
      boxW,
      boxH,
      usedL: 0,
      usedW: 0,
      usedH: 0,
      pattern: "none",
      patternRows: null
    };
  }
  
  const orientations = [
    { l: boxL, w: boxW, h: boxH, label: "upright" },
    { l: boxW, w: boxL, h: boxH, label: "upright-rotated" },
  ];
  
  if (allowVerticalFlip) {
    orientations.push(
      { l: boxW, w: boxH, h: boxL, label: "laid-side-l" },
      { l: boxL, w: boxH, h: boxW, label: "laid-side-w" },
      { l: boxH, w: boxL, h: boxW, label: "laid-h-l" },
      { l: boxH, w: boxW, h: boxL, label: "laid-h-w" }
    );
  }
  
  const candidates = [];
  
  // Try uniform patterns
  const fitUniform = (o) => {
    const countL = Math.floor(spaceL / o.l);
    const countW = Math.floor(spaceW / o.w);
    const layers = Math.floor(spaceH / o.h);
    
    if (countL <= 0 || countW <= 0 || layers <= 0) return null;
    
    const perLayer = countL * countW;
    return {
      pattern: o.label,
      countL,
      countW,
      layers,
      perLayer,
      total: perLayer * layers,
      boxL: o.l,
      boxW: o.w,
      boxH: o.h,
      usedL: countL * o.l,
      usedW: countW * o.w,
      usedH: layers * o.h,
      patternRows: null,
    };
  };
  
  // Try mixed patterns
  const fitMixed = (o) => {
    if (o.l === o.w) return null; // No benefit to mixing if square
    
    const layers = Math.floor(spaceH / o.h);
    if (layers <= 0) return null;
    
    const patternRows = [];
    let yUsed = 0;
    let totalInLayer = 0;
    let remainingW = spaceW;
    let maxUsedL = 0;
    let rowIndex = 0;
    
    while (remainingW >= Math.min(o.l, o.w)) {
      const rotated = rowIndex % 2 === 1;
      const rowL = rotated ? o.w : o.l;
      const rowW = rotated ? o.l : o.w;
      
      if (remainingW < rowW) break;
      
      const cols = Math.floor(spaceL / rowL);
      if (cols === 0) break;
      
      patternRows.push({ rotated, countL: cols, boxL: rowL, boxW: rowW });
      totalInLayer += cols;
      maxUsedL = Math.max(maxUsedL, cols * rowL);
      yUsed += rowW;
      remainingW -= rowW;
      rowIndex++;
    }
    
    if (!patternRows.length) return null;
    
    return {
      pattern: "mixed-" + o.label,
      layers,
      perLayer: totalInLayer,
      total: totalInLayer * layers,
      boxL: o.l,
      boxW: o.w,
      boxH: o.h,
      usedL: maxUsedL,
      usedW: yUsed,
      usedH: layers * o.h,
      patternRows,
    };
  };
  
  // Test all orientations
  orientations.forEach((o) => {
    const uniform = fitUniform(o);
    if (uniform) candidates.push(uniform);
    
    const mixed = fitMixed(o);
    if (mixed) candidates.push(mixed);
  });
  
  // Return best option or empty result
  if (!candidates.length) {
    return {
      countL: 0,
      countW: 0,
      layers: 0,
      perLayer: 0,
      total: 0,
      boxL,
      boxW,
      boxH,
      usedL: 0,
      usedW: 0,
      usedH: 0,
      pattern: "none",
      patternRows: null
    };
  }
  
  // Sort by total cartons, then by per-layer efficiency
  candidates.sort((a, b) => b.total - a.total || b.perLayer - a.perLayer);
  return candidates[0];
}

// =====================================================
// MAIN APPLICATION COMPONENT
// =====================================================
function CartonPlanner() {
  const [product, setProduct] = useState({ l: 100, w: 150, h: 250, weight: 1 });
  const [carton, setCarton] = useState({ l: 300, w: 250, h: 450 });
  const [limits, setLimits] = useState({
    palletL: 1200,
    palletW: 1000,
    palletH: 1350,
    cartonGrossMax: 12,
  });
  const [allowVerticalFlip, setAllowVerticalFlip] = useState(true);
  
  // Calculate units per carton
  const unitsPerCarton = useMemo(() => {
    if (product.l <= 0 || product.w <= 0 || product.h <= 0 || 
        carton.l <= 0 || carton.w <= 0 || carton.h <= 0) {
      return 0;
    }
    return Math.floor(carton.l / product.l) *
           Math.floor(carton.w / product.w) *
           Math.floor(carton.h / product.h);
  }, [carton, product]);
  
  const cartonWeight = unitsPerCarton * product.weight;
  const overweight = cartonWeight > limits.cartonGrossMax;
  
  // Calculate pallet configuration
  const palletTile = useMemo(
    () => bestTile(carton.l, carton.w, carton.h, limits.palletL, limits.palletW, limits.palletH, allowVerticalFlip),
    [carton, limits, allowVerticalFlip]
  );
  
  const palletLayers = palletTile.layers;
  const cartonsPerPallet = palletTile.perLayer * palletLayers;
  const unitsPerPallet = cartonsPerPallet * unitsPerCarton;
  const palletWeight = cartonsPerPallet * cartonWeight;
  
  // Input handler
  const handleNumberInput = (setter, obj, key, value) => {
    const num = parseFloat(value);
    if (!isNaN(num) && num >= 0) {
      setter({ ...obj, [key]: num });
    }
  };
  
  return (
    <div className="p-6 space-y-6">
      <header className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Carton & Pallet Planner</h1>
        <div className="text-sm text-gray-600">All dimensions in <b>mm</b> and weights in <b>kg</b>.</div>
      </header>
      
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Input Panel */}
        <div className="lg:col-span-1 space-y-4">
          <InputSection
            title="Product"
            fields={[
              ["l", "Length", product.l],
              ["w", "Width", product.w],
              ["h", "Height", product.h],
              ["weight", "Weight (kg)", product.weight],
            ]}
            onChange={(key, value) => handleNumberInput(setProduct, product, key, value)}
          />
          
          <section className="p-4 border rounded-2xl shadow-sm bg-white">
            <h3 className="font-semibold mb-2">Carton (external)</h3>
            {[
              ["l", "Length", carton.l],
              ["w", "Width", carton.w],
              ["h", "Height", carton.h],
            ].map(([key, label, value]) => (
              <label key={key} className="block text-sm my-1">
                {label}
                <input
                  type="number"
                  min="0"
                  value={value}
                  onChange={(e) => handleNumberInput(setCarton, carton, key, e.target.value)}
                  className="border rounded-lg px-2 py-1 ml-2 w-28"
                />
              </label>
            ))}
            <div className={`mt-2 text-sm ${overweight ? "text-red-600 font-semibold" : "text-gray-600"}`}>
              {unitsPerCarton} units / carton · {cartonWeight.toFixed(2)} kg gross
              {overweight && <span> — exceeds {limits.cartonGrossMax} kg limit!</span>}
            </div>
            <label className="flex items-center space-x-2 mt-3 text-sm">
              <input
                type="checkbox"
                checked={allowVerticalFlip}
                onChange={(e) => setAllowVerticalFlip(e.target.checked)}
              />
              <span>Allow cartons to be laid on their side (vertical flipping)</span>
            </label>
          </section>
          
          <section className="p-4 border rounded-2xl shadow-sm bg-white">
            <h3 className="font-semibold mb-2">Pallet (CHEP)</h3>

            {/* Pallet size dropdown */}
            <label className="block text-sm my-1">
              Preset size:
              <select
                className="border rounded-lg px-2 py-1 ml-2 w-60"
                onChange={(e) => {
                  const selected = PALLET_SIZES.find(p => p.label === e.target.value);
                  if (selected && selected.L && selected.W) {
                    setLimits({ ...limits, palletL: selected.L, palletW: selected.W });
                  }
                }}
                value={
                  PALLET_SIZES.find(
                    p => p.L === limits.palletL && p.W === limits.palletW
                  )?.label || "Custom size"
                }
              >
                {PALLET_SIZES.map(p => (
                  <option key={p.label} value={p.label}>{p.label}</option>
                ))}
              </select>
            </label>

            {/* Manual inputs (still editable) */}
            {[
              ["palletL", "Length", limits.palletL],
              ["palletW", "Width", limits.palletW],
              ["palletH", "Usable height", limits.palletH],
              ["cartonGrossMax", "Max carton gross (kg)", limits.cartonGrossMax],
            ].map(([key, label, value]) => (
              <label key={key} className="block text-sm my-1">
                {label}
                <input
                  type="number"
                  min="0"
                  step={key === "cartonGrossMax" ? "0.01" : "1"}
                  value={value}
                  onChange={(e) => handleNumberInput(setLimits, limits, key, e.target.value)}
                  className="border rounded-lg px-2 py-1 ml-2 w-28"
                />
              </label>
            ))}

            <div className="mt-2 text-sm text-gray-600">
              Total weight: {palletWeight.toFixed(2)} kg
            </div>
          </section>
        </div>
        
        {/* Visualization Panel */}
        <div className="lg:col-span-2 space-y-4">
          
          <PalletView3D
            palletL={limits.palletL}
            palletW={limits.palletW}
            palletH={limits.palletH}
            cartonL={palletTile.boxL}
            cartonW={palletTile.boxW}
            cartonH={palletTile.boxH}
            pattern={palletTile.pattern}
            perLayer={palletTile.perLayer}
            layers={palletLayers}
            patternRows={palletTile.patternRows}
            palletTile={palletTile}
            cartonWeight={cartonWeight}
          />

          <div className="text-s text-gray-500 mt-1 font-bold text-green-500">
            {allowVerticalFlip
              ? "All orientations, including side-laying and flat, will be tested."
              : "Only upright and horizontal rotations will be considered (no side or flat flips)."}
          </div>
          
          <section className="grid md:grid-cols-2 gap-4">
            <MetricCard
              title="Carton"
              subtitle={`${carton.l}×${carton.w}×${carton.h} mm`}
              value={unitsPerCarton}
              unit="units"
              footer={`${cartonWeight.toFixed(2)} kg gross ${overweight ? "(OVER LIMIT)" : ""}`}
              error={overweight}
            />
            
            <MetricCard
              title="Per Pallet"
              subtitle={`${palletTile.perLayer} cartons/layer × ${palletLayers} layers`}
              value={numberFmt(cartonsPerPallet)}
              unit="cartons"
              footer={`${numberFmt(unitsPerPallet)} units · ${palletWeight.toFixed(1)} kg total`}
            />
          </section>
          
          <section className="p-4 border rounded-2xl shadow-sm bg-white">
            <h4 className="font-semibold mb-2">Optimization Details</h4>
            <div className="text-sm">
              <h5 className="font-medium text-gray-700 mb-1">Pallet Configuration</h5>
              <ul className="text-gray-600 space-y-0.5">
                <li>• Pattern: {palletTile.pattern}</li>
                <li>• Cartons per layer: {palletTile.perLayer}</li>
                <li>• Space efficiency: {((palletTile.usedL * palletTile.usedW) / (limits.palletL * limits.palletW) * 100).toFixed(1)}%</li>
                <li>• Vertical layers: {palletLayers}</li>
                <li>• Stack height: {palletLayers * palletTile.boxH} mm</li>
              </ul>
            </div>
          </section>
          
          <section className="p-4 border rounded-2xl shadow-sm bg-yellow-50">
            <h4 className="font-semibold mb-2">Notes & Tips</h4>
            <ul className="list-disc pl-5 text-sm text-gray-700 space-y-1">
              <li>3D view shows actual carton stacking on pallet - click and drag to rotate view</li>
              <li>Toggle between 2D and 3D views using the buttons above the visualization</li>
              <li>Automatically tests all orientations based on your settings</li>
              <li>Yellow boxes in 2D view indicate rotated cartons (90° rotation)</li>
              <li>All calculations use integer tiling (floor function)</li>
              <li>Red warnings indicate weight limit violations</li>
            </ul>
          </section>
        </div>
      </div>
    </div>
  );
}

// =====================================================
// REUSABLE UI COMPONENTS
// =====================================================
function InputSection({ title, fields, onChange, footer }) {
  return (
    <section className="p-4 border rounded-2xl shadow-sm bg-white">
      <h3 className="font-semibold mb-2">{title}</h3>
      {fields.map(([key, label, value]) => (
        <label key={key} className="block text-sm my-1">
          {label}
          <input
            type="number"
            min="0"
            step={key === "weight" || key === "cartonGrossMax" ? "0.01" : "1"}
            value={value}
            onChange={(e) => onChange(key, e.target.value)}
            className="border rounded-lg px-2 py-1 ml-2 w-28"
          />
        </label>
      ))}
      {footer && (
        <div className="mt-2 text-sm text-gray-600">{footer}</div>
      )}
    </section>
  );
}

function MetricCard({ title, subtitle, value, unit, footer, error = false }) {
  return (
    <div className="p-4 border rounded-2xl shadow-sm bg-white">
      <h4 className="font-semibold mb-1">{title}</h4>
      {subtitle && (
        <div className="text-sm text-gray-600 mb-2">{subtitle}</div>
      )}
      <div className="text-xl font-bold">{value} {unit}</div>
      {footer && (
        <div className={`text-sm ${error ? "text-red-600 font-semibold" : "text-gray-600"}`}>
          {footer}
        </div>
      )}
    </div>
  );
}

// Mount the application
ReactDOM.createRoot(document.getElementById("root")).render(React.createElement(CartonPlanner));
</script>
</body>
</html>