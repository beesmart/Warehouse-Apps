<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pallet Carton Planner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body class="bg-gray-100">
<div id="root"></div>

<!-- React + ReactDOM -->
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<!-- Babel -->
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<script type="text/babel">
const { useState, useMemo, useRef, useEffect } = React;

/* =====================================================
   3D PALLET VIEW - THREE.JS
===================================================== */
function PalletView3D({ palletL, palletW, palletH, cartonL, cartonW, cartonH, pattern, perLayer, layers, patternRows, palletTile, cartonWeight }) {
  const mountRef = useRef(null);
  const rendererRef = useRef(null);
  const frameRef = useRef(null);
  const [viewMode, setViewMode] = useState('3D');

  useEffect(() => {
    if (!mountRef.current || viewMode !== '3D') return;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf5f5f5);

    const width = mountRef.current.clientWidth;
    const height = 400;
    const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);
    camera.position.set(2500, 2000, 2500);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);
    renderer.shadowMap.enabled = true;
    mountRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(1000, 2000, 1000);
    scene.add(directionalLight);

    // Ground plane
    const groundGeometry = new THREE.PlaneGeometry(5000, 5000);
    const groundMaterial = new THREE.MeshLambertMaterial({ color: 0xe0e0e0 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -10;
    scene.add(ground);

    // Pallet base
    const palletBaseGeometry = new THREE.BoxGeometry(palletL, 100, palletW);
    const palletBaseMaterial = new THREE.MeshLambertMaterial({ color: 0x8b7355 });
    const palletBase = new THREE.Mesh(palletBaseGeometry, palletBaseMaterial);
    palletBase.position.y = 50;
    scene.add(palletBase);

    // Cartons
    const cartonGeometry = new THREE.BoxGeometry(1, 1, 1);
    const cartonMaterial = new THREE.MeshLambertMaterial({ color: 0x3b82f6 });
    const edgeMat = new THREE.LineBasicMaterial({ color: 0x1e40af });

    for (let layer = 0; layer < layers; layer++) {
      const yOffset = 100 + layer * cartonH + cartonH / 2;

      const boxL = palletTile.boxL || cartonL;
      const boxW = palletTile.boxW || cartonW;
      const countL = palletTile.countL || Math.floor(palletL / boxL);
      const countW = palletTile.countW || Math.floor(palletW / boxW);

      const usedL = countL * boxL;
      const usedW = countW * boxW;
      const xStart = -usedL / 2;
      const zStart = -usedW / 2;

      for (let i = 0; i < countL; i++) {
        for (let j = 0; j < countW; j++) {
          const carton = new THREE.Mesh(cartonGeometry, cartonMaterial);
          const edges = new THREE.LineSegments(new THREE.EdgesGeometry(cartonGeometry), edgeMat);

          carton.scale.set(boxL, cartonH, boxW);
          edges.scale.set(boxL, cartonH, boxW);

          const xPos = xStart + boxL / 2 + i * boxL;
          const zPos = zStart + boxW / 2 + j * boxW;
          carton.position.set(xPos, yOffset, zPos);
          edges.position.set(xPos, yOffset, zPos);

          scene.add(carton);
          scene.add(edges);
        }
      }
    }

    // Drag rotate
    let isDragging = false;
    let prevX = 0, prevY = 0, rotX = Math.PI / 4, rotY = 0.3;

    const onDown = e => { isDragging = true; prevX = e.clientX; prevY = e.clientY; };
    const onUp = () => { isDragging = false; };
    const onMove = e => {
      if (!isDragging) return;
      const dx = e.clientX - prevX;
      const dy = e.clientY - prevY;
      rotX += dx * 0.01;
      rotY = Math.max(0.1, Math.min(1.2, rotY - dy * 0.005));
      prevX = e.clientX; prevY = e.clientY;
    };

    mountRef.current.addEventListener('mousedown', onDown);
    mountRef.current.addEventListener('mouseup', onUp);
    mountRef.current.addEventListener('mouseleave', onUp);
    mountRef.current.addEventListener('mousemove', onMove);

    const animate = () => {
      frameRef.current = requestAnimationFrame(animate);
      const radius = 3000;
      const heightY = 800 + rotY * 1500;
      camera.position.x = Math.sin(rotX) * radius;
      camera.position.y = heightY;
      camera.position.z = Math.cos(rotX) * radius;
      camera.lookAt(0, palletH / 2, 0);
      renderer.render(scene, camera);
    };
    animate();

    return () => {
      cancelAnimationFrame(frameRef.current);
      mountRef.current.removeEventListener('mousedown', onDown);
      mountRef.current.removeEventListener('mouseup', onUp);
      mountRef.current.removeEventListener('mouseleave', onUp);
      mountRef.current.removeEventListener('mousemove', onMove);
      if (rendererRef.current) {
        mountRef.current.removeChild(rendererRef.current.domElement);
        rendererRef.current.dispose();
      }
    };
  }, [palletL, palletW, palletH, cartonL, cartonW, cartonH, palletTile, layers, viewMode]);

  return (
    <div className="p-4 border rounded-2xl shadow-sm bg-white">
      <div className="flex justify-between items-center mb-2">
        <h4 className="font-semibold">Pallet Visualization</h4>
        <div>
          <button
            onClick={() => setViewMode('3D')}
            className={`px-3 py-1 text-sm rounded-lg ${viewMode==='3D'?'bg-blue-500 text-white':'bg-gray-100'}`}
          >3D</button>
        </div>
      </div>
      <div ref={mountRef} className="bg-gray-50 rounded-xl overflow-hidden" style={{ height: '400px' }} />
      <div className="text-xs text-gray-500 mt-2 text-center">
        Click and drag to rotate view
      </div>
    </div>
  );
}

/* =====================================================
   BEST TILE CALCULATOR (simplified for pallets only)
===================================================== */
function bestTile(boxL, boxW, boxH, spaceL, spaceW, spaceH, canFlip = true) {
  const fit = (bl, bw, bh, orientation) => {
    const countL = Math.floor(spaceL / bl);
    const countW = Math.floor(spaceW / bw);
    const layers = Math.floor(spaceH / bh);
    return {
      countL, countW, layers,
      perLayer: countL * countW,
      totalCartons: countL * countW * layers,
      boxL: bl, boxW: bw, boxH: bh,
      usedL: countL * bl,
      usedW: countW * bw,
      orientation
    };
  };

  const candidates = [];

  if (canFlip) {
    // Upright or laid flat
    candidates.push(
      fit(boxL, boxW, boxH, "upright"),
      fit(boxL, boxH, boxW, "laid-flat")
    );
  } else {
    candidates.push(
      fit(boxL, boxW, boxH, "upright"),
      fit(boxW, boxL, boxH, "rotated")
    );
  }

  return candidates.sort((a, b) => b.totalCartons - a.totalCartons)[0];
}

/* =====================================================
   MAIN APP
===================================================== */
function CartonPlanner() {
  const [carton, setCarton] = useState({ l: 500, w: 200, h: 500, weight: 10, canFlip: true });
  const [pallet, setPallet] = useState({ L: 1000, W: 1000, H: 1000 });

  const palletTile = useMemo(() => bestTile(
    carton.l, carton.w, carton.h,
    pallet.L, pallet.W, pallet.H,
    carton.canFlip
  ), [carton, pallet]);

  const cartonsPerPallet = palletTile.perLayer * palletTile.layers;
  const totalWeight = cartonsPerPallet * carton.weight;

  return (
    <div className="p-6 space-y-6">
      <h1 className="text-2xl font-bold">Pallet Carton Planner</h1>
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">

        {/* Inputs */}
        <div className="space-y-4">
          <section className="p-4 border rounded-2xl bg-white shadow-sm">
            <h3 className="font-semibold mb-2">Carton</h3>
            {["l","w","h","weight"].map((k) => (
              <label key={k} className="block text-sm my-1">
                {k === "weight" ? "Weight (kg)" : k.toUpperCase()}:
                <input
                  type="number"
                  value={carton[k]}
                  onChange={e => setCarton({ ...carton, [k]: parseFloat(e.target.value) || 0 })}
                  className="border rounded-lg px-2 py-1 ml-2 w-24"
                />
              </label>
            ))}
            <label className="flex items-center text-sm mt-3 mb-2">
              <input
                type="checkbox"
                checked={carton.canFlip}
                onChange={e => setCarton({ ...carton, canFlip: e.target.checked })}
                className="mr-2"
              />
              Can be flipped/laid flat
            </label>
          </section>

          <section className="p-4 border rounded-2xl bg-white shadow-sm">
            <h3 className="font-semibold mb-2">Pallet</h3>
            {["L","W","H"].map((k) => (
              <label key={k} className="block text-sm my-1">
                {k}:
                <input
                  type="number"
                  value={pallet[k]}
                  onChange={e => setPallet({ ...pallet, [k]: parseFloat(e.target.value) || 0 })}
                  className="border rounded-lg px-2 py-1 ml-2 w-24"
                />
              </label>
            ))}
          </section>
        </div>

        {/* Output */}
        <div className="lg:col-span-2 space-y-4">
          <PalletView3D
            palletL={pallet.L}
            palletW={pallet.W}
            palletH={pallet.H}
            cartonL={palletTile.boxL}
            cartonW={palletTile.boxW}
            cartonH={palletTile.boxH}
            pattern={palletTile.pattern}
            perLayer={palletTile.perLayer}
            layers={palletTile.layers}
            palletTile={palletTile}
            cartonWeight={carton.weight}
          />

          <div className="p-4 border rounded-2xl bg-white shadow-sm grid grid-cols-3 text-sm text-gray-700">
            <div>
              <h4 className="font-semibold">Carton</h4>
              <p>{carton.l}×{carton.w}×{carton.h} mm</p>
            </div>
            <div>
              <h4 className="font-semibold">Per Pallet</h4>
              <p>{palletTile.perLayer} cartons/layer × {palletTile.layers} layers</p>
              <p>Total: {cartonsPerPallet}</p>
            </div>
            <div>
              <h4 className="font-semibold">Weight</h4>
              <p>{totalWeight.toFixed(1)} kg</p>
            </div>
          </div>
        </div>

      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<CartonPlanner />);
</script>
</body>
</html>
